using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Diagnostics;
using System.Reflection;
using System.Threading;
using System.IO;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;

/*
Credit is due to ideas, inspiration and code drawn from these places among others:
https://www.phrozensoft.com
https://interestingmalware.blogspot.com
https://adlice.com 
https://github.com/ZVVZ
https://github.com/Workshell/
https://github.com/bahnahnah
https://StackOverflow.com
https://msdn.com
http://crypters.net
Tasiopoulos Vasilis Powerpoint regarding defeating AV's
http://www.autosectools.com/
https://blackc0.de

LICENSE:
Use as you please, source or binary. 
Credit me or not, up to you.
Use responsibly. 
I'm not responsible for any malfunction or damage and you use at your own risk

 
*/
namespace MalwareBlock
{

    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();

        }

        TextWriter _writer = null;
        /// <summary>
        /// Deprecated at the moment
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void Form1_Load(object sender, EventArgs e)
        {

            // Instantiate the writer
            _writer = new TextBoxStreamWriter(txtConsole);
            // Redirect the out Console stream
            Console.SetOut(_writer);

            Console.WriteLine("Click the button to run scan.");
        }

        private void txtSayHello_Click(object sender, EventArgs e)
        {
            // Writing to the Console now causes the text to be displayed in the text box.
            Console.WriteLine("Hello world");
        }

        /// <summary>
        /// Program entry point and welcome
        /// </summary>
        /// <param name="args"></param>
        /*
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form1());
            InitializeComponent();
            TextWriter _writer = null;

            // Instantiate the writer
            _writer = new TextBoxStreamWriter(txtConsole);
            // Redirect the out Console stream
            Console.SetOut(_writer);

            Console.WriteLine("Click the button to run scan.");
        }
        */

        /// <summary>
        /// Finds all currently running 32bit processes.
        /// </summary>
        /// 
        static void ProcessHandler()
        {
            //_writer = new ListBoxWriter(listBox1);
            while (isRunning)
            {
                foreach (Process p in Process.GetProcesses())
                {

                    if (p.Is64Bit())
                        continue;
                    if (p.Id == Process.GetCurrentProcess().Id)
                        continue;
                    if (p.MainModule.FileName.Contains(".vshost.exe") || p.MainModule.FileName.Equals(Assembly.GetExecutingAssembly().Location))
                        continue;

                    if (activeProcesses.Contains(p.Id))
                        continue;

                    activeProcesses.Add(p.Id);
                    //Console.WriteLine("Process: " + p.ProcessName + ".exe started with PID: " + p.Id);
                    resultHandler(p, module, processPID);

                }
                // Remove old processes from list every 30 seconds
                int time = (int)Math.Abs((DateTime.Now - lastCleaned).TotalSeconds);
                if (time >= 30)
                {
                    cleaner();
                    lastCleaned = DateTime.Now;
                }
                GC.Collect();
                Thread.Sleep(750);
            }
        }

        private static List<int> activeProcesses = new List<int>();
        private static bool isRunning = true;
        /// <summary>
        /// Removes processes that are no longer running from the process list.
        /// </summary>
        private static void cleaner()
        {
            List<int> removeMe = new List<int>();
            foreach (int i in activeProcesses)
            {
                // If fails to get PID, remove from active process list
                try
                {
                    Process.GetProcessById(i);
                }
                catch (Exception)
                {
                    removeMe.Add(i);
                }
            }
            // Separate loops to prevent error
            foreach (int deadPID in removeMe)
            {
                if (activeProcesses.Contains(deadPID))
                    activeProcesses.Remove(deadPID);
            }
        }

        /*public static void getText(Label label1)
        {
            label1.Text = "New label1 text";
        }
        public static void textReplaceWith(String s, Label label1)
        {
            label1.Text = s;
        }

        public static Label pLabel;

        //this method runs when your form opens
        public void LoadTextForm()
        {
            pLabel = label1; //assign your private label to the static one
        }

        //Any time getText() is used, the label text updates no matter where it's used
        public static void getText()
        {
            Form1.textReplaceWith("New label1 text", pLabel); //Form1 method's used 
        }
        */




        private static DateTime lastCleaned = new DateTime(2016, 6, 6);

        private static ProcessModule module;
        private static int processPID;


        /// <summary>
        /// Determine if process has been created that has file headers that don't match process headers.
        /// </summary>
        /// <param name="p">Process to analyze.</param>
        private static void resultHandler(Process p, ProcessModule module, int processPID)
        {
            //Console.WriteLine("Analyzing process: " + p.ProcessName + ".exe with PID: " + p.Id);
            //p.Suspend();

            if (mismatchSection(p.Modules[0], p.Id))
            {
                p.Kill();
                Console.WriteLine("Headers don't match, likely malware! Killed process: " + p.ProcessName + ".exe with PID: " + p.Id);
                if (module.FileName == null)
                {
                    Application.Exit();
                }
                string modulePath = module.FileName;

                PEInfomation procPE = PELoader.Load(processPID, module);
                PEInfomation filePE = PELoader.Load(modulePath);
                //Log(procPE, filePE);
                return;
            }

            Console.WriteLine(p.ProcessName + ".exe is clean - " + "PID: " + p.Id);
            ///getText(label1);
            //label1.Text = p.ProcessName;
            //p.Resume();
        }

        private void Remove(Process p, ProcessModule module, int processPID)
        {

            string modulePath = module.FileName;
            PEInfomation procPE = PELoader.Load(processPID, module);
            PEInfomation filePE = PELoader.Load(modulePath);
            string messageboxmesg = ("Malware Detected! \nKilled : " + p.ProcessName + ".exe - PID: " + p.Id);
            Console.WriteLine(messageboxmesg);

        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="module">Main module of process being analyzed</param>
        /// <param name="processPID">Process id of process being analyzed</param>
        /// <returns></returns>
        private static bool mismatchSection(ProcessModule module, int processPID)
        {
            //Catch if process has been killed already
            //try
            //{
            //    Process.GetProcessById(processPID);
            //}
            //catch
            //{
            //    return false;
            //}

            string modulePath = module.FileName;
            PEInfomation procPE = PELoader.Load(processPID, module);
            PEInfomation filePE = PELoader.Load(modulePath);
            int mismatches = 0;

            mismatches += compareHeaders(procPE.FileHeader, filePE.FileHeader); // File Header
            mismatches += compareHeaders(procPE.OptionalHeader32, filePE.OptionalHeader32); // Optional Header
            int sectionTotal = Math.Min(Convert.ToInt32(procPE.Overview.NumberOfSections), Convert.ToInt32(filePE.Overview.NumberOfSections));

            for (int i = 0; i < sectionTotal; i++)
            {
                mismatches += compareHeaders(procPE.Sections[i], filePE.Sections[i]);
            }

            return (mismatches >= 8);
        }//adjust this 


        /// <summary>
        /// Compares PE header in memory and file PE header and counts the differences.
        /// </summary>
        /// <typeparam name="T">Image header type</typeparam>
        /// <param name="procPE">Process PE header info</param>
        /// <param name="filePE">File PE header info</param>
        /// <returns></returns>
        private static int compareHeaders<T>(T procPE, T filePE)
        {
            Type compareHeaders = typeof(T);

            int Tmismatches = 0;

            foreach (FieldInfo f in compareHeaders.GetFields())
            {
                object oProc = f.GetValue(procPE);
                object oFile = f.GetValue(filePE);

                if (oProc.ToString() != oFile.ToString())
                    Tmismatches++;
            }
            return Tmismatches;
        }



        private void button1_Click(object sender, EventArgs e)
        {
            new Thread(ProcessHandler).Start();
        }
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Portable Executable in-stream

    /// <summary>
    /// Loads Portable Executable Data
    /// </summary>
    /// <returns></returns>
    public class PELoader
    {

        [DllImport("kernel32.dll")]
        private static extern IntPtr OpenProcess(uint access, bool inherit, int id);

        [DllImport("kernel32.dll")]
        private static extern bool CloseHandle(IntPtr handle);

        [DllImport("kernel32.dll")]
        private static extern bool ReadProcessMemory(IntPtr process, IntPtr baseAddress, byte[] buffer, int bufferSize, int bytesRead);

        public static PEInfomation Load(string file)
        {
            if (!File.Exists(file)) throw new ArgumentException("File does not exist", "file");
            return Load(File.ReadAllBytes(file), file);
        }

        public static PEInfomation Load(int ProcessID, ProcessModule module)
        {
            return Load(ProcessID, module.BaseAddress);
        }


        public static PEInfomation Load(int ProcessID, IntPtr moduleAddress)
        {
            PEInfomation info = new PEInfomation(ProcessID, moduleAddress);
            return vLoad(info, moduleAddress);
        }

        public static PEInfomation Load(IntPtr procHandle, IntPtr moduleAddress)
        {
            PEInfomation info = new PEInfomation(procHandle, moduleAddress);
            return vLoad(info, moduleAddress);
        }

        public static PEInfomation Load(byte[] data, string path)
        {
            if (data == null) throw new ArgumentNullException("data");

            PEInfomation info = new PEInfomation(path);

            info.DosHeader = StructFromBytes<IMAGE_DOS_HEADER>(data, 0);
            info.FileHeader = StructFromBytes<IMAGE_FILE_HEADER>(data, Convert.ToInt32(info.DosHeader.e_lfanew));
            info.OptionalHeader32 = StructFromBytes<IMAGE_OPTIONAL_HEADER32>(data, Convert.ToInt32(info.DosHeader.e_lfanew) + Marshal.SizeOf(info.FileHeader));
            info.DataDirectories = StructFromBytes<IMAGE_DATA_DIRECTORIES>(data, Convert.ToInt32(info.DosHeader.e_lfanew) + Marshal.SizeOf(info.FileHeader) + Marshal.SizeOf(info.OptionalHeader32));

            info.Sections = new IMAGE_SECTION_HEADER[info.FileHeader.NumberOfSections];
            int sectionsBase = Convert.ToInt32(info.DosHeader.e_lfanew) + Marshal.SizeOf(info.FileHeader) + Marshal.SizeOf(info.OptionalHeader32) + Marshal.SizeOf(info.DataDirectories);
            int sizeOfSection = Marshal.SizeOf(typeof(IMAGE_SECTION_HEADER));
            for (int i = 0; i < info.Sections.Length; i++)
            {
                int sectionLocation = sectionsBase + (sizeOfSection * i);
                info.Sections[i] = StructFromBytes<IMAGE_SECTION_HEADER>(data, sectionLocation);
            }

            info.WriteOverview();
            return info;

        }

        private static PEInfomation vLoad(PEInfomation info, IntPtr baseAddress)
        {
            IntPtr handle = info.GetProcessHandle();
            if (handle == IntPtr.Zero)
                throw new ArgumentException("Invalid process", "info");

            info.DosHeader = StructFromMemory<IMAGE_DOS_HEADER>(handle, baseAddress);
            IntPtr imageBase = new IntPtr(info.DosHeader.e_lfanew + (uint)baseAddress);

            info.FileHeader = StructFromMemory<IMAGE_FILE_HEADER>(handle, imageBase);
            info.OptionalHeader32 = StructFromMemory<IMAGE_OPTIONAL_HEADER32>(handle, imageBase + Marshal.SizeOf(info.FileHeader));
            info.DataDirectories = StructFromMemory<IMAGE_DATA_DIRECTORIES>(handle, imageBase + Marshal.SizeOf(info.FileHeader) + Marshal.SizeOf(info.OptionalHeader32));

            info.Sections = new IMAGE_SECTION_HEADER[info.FileHeader.NumberOfSections];
            IntPtr sectionsBase = imageBase + Marshal.SizeOf(info.FileHeader) + Marshal.SizeOf(info.OptionalHeader32) + Marshal.SizeOf(info.DataDirectories);
            int sizeOfSection = Marshal.SizeOf(typeof(IMAGE_SECTION_HEADER));
            for (int i = 0; i < info.Sections.Length; i++)
            {
                IntPtr sectionLocation = sectionsBase + (sizeOfSection * i);
                info.Sections[i] = StructFromMemory<IMAGE_SECTION_HEADER>(handle, sectionLocation);
            }

            info.CloseProcessHandle();

            info.WriteOverview();
            return info;
        }

        public static IntPtr OpenProcessHandle(int pid)
        {
            return OpenProcess(0x1F0FFF, false, pid);
        }

        public static void CloseProcessHandle(IntPtr handle)
        {
            if (handle != IntPtr.Zero)
                CloseHandle(handle);
        }

        public static T StructFromMemory<T>(IntPtr handle, IntPtr address)
        {
            int structSize = Marshal.SizeOf(typeof(T));
            byte[] buffer = new byte[structSize];
            ReadProcessMemory(handle, address, buffer, buffer.Length, 0);
            return StructFromBytes<T>(buffer, 0);
        }

        public static T StructFromBytes<T>(byte[] data, int offset)
        {
            int structSize = Marshal.SizeOf(typeof(T));
            IntPtr gAlloc = Marshal.AllocHGlobal(structSize);

            Marshal.Copy(data, offset, gAlloc, structSize);
            T retStruct = (T)Marshal.PtrToStructure(gAlloc, typeof(T));
            Marshal.FreeHGlobal(gAlloc);
            return retStruct;
        }

        public static PEInfomation DisectSelf()
        {
            Process p = Process.GetCurrentProcess();
            return Load(p.Id, p.Modules[0]);
        }




    }

    /// <summary>
    /// Deals with Portable Executable data to be later called on by analytic functions
    /// </summary>
    /// <returns></returns>
    public class PEInfomation
    {

        [DllImport("kernel32.dll")]
        private static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);

        [DllImport("kernel32.dll")]
        private static extern bool CloseHandle(IntPtr handle);

        [DllImport("kernel32.dll")]
        private static extern IntPtr LoadLibrary(string path);

        [DllImport("kernel32.dll")]
        private static extern bool FreeLibrary(IntPtr handle);

        [DllImport("psapi.dll")]
        private static extern uint GetModuleFileNameEx(IntPtr hProcess, IntPtr hModule, StringBuilder lpBaseName, int nSize);

        public string PESource { get; set; }
        public bool IsProcess { get; private set; }
        public IntPtr ModuleBaseAddress { get; }

        public int ProcessID;
        public string FilePath;
        IntPtr Handle = IntPtr.Zero;
        IntPtr loadedModuleHandle = IntPtr.Zero;

        public IMAGE_DOS_HEADER DosHeader;
        public IMAGE_FILE_HEADER FileHeader;
        public IMAGE_OPTIONAL_HEADER32 OptionalHeader32;
        public IMAGE_DATA_DIRECTORIES DataDirectories;
        public IMAGE_SECTION_HEADER[] Sections;
        public IMAGE_OVERVIEW Overview;

        public const int SizeOfDosHeader = 0x40;
        public const int SizeOfFileHeader = 0x18;
        public const int SizeOfOptionalHeader = 0x60;
        public const int SizeOfDataDirectories = 0x80;
        public const int SizeOfSectionHeader = 0x28;

        public PEInfomation(string path)
        {
            FilePath = path;
            IsProcess = false;
        }

        void LoadModuleInfo()
        {
            StringBuilder sb = new StringBuilder(255);
            GetModuleFileNameEx(GetProcessHandle(), ModuleBaseAddress, sb, 255);
            FilePath = sb.ToString();

            /*
            ModuleInfo = new MODULE_INFO();
            GetModuleInformation(GetProcessHandle(), ModuleBaseAddress, out ModuleInfo, Marshal.SizeOf(typeof(MODULE_INFO)));
            Debug.WriteLine(new Win32Exception(Marshal.GetLastWin32Error()).Message);
            */

            CloseProcessHandle();

            IsProcess = true;
        }

        public IntPtr LoadModule()
        {
            if (loadedModuleHandle != IntPtr.Zero)
                return loadedModuleHandle;

            loadedModuleHandle = LoadLibrary(FilePath);


            return loadedModuleHandle;
        }

        public void UnloadModule()
        {
            if (loadedModuleHandle == IntPtr.Zero)
                return;

            if (FreeLibrary(loadedModuleHandle))
                loadedModuleHandle = IntPtr.Zero;
        }


        public PEInfomation(int pId, IntPtr _module)
        {
            ProcessID = pId;
            ModuleBaseAddress = _module;
            LoadModuleInfo();
        }

        public PEInfomation(IntPtr procHandle, IntPtr _module)
        {
            Handle = procHandle;
            ProcessID = 0;
            ModuleBaseAddress = _module;
            LoadModuleInfo();
        }


        public void WriteOverview()
        {
            Overview.AddressOfEntrypoint = OptionalHeader32.AddressOfEntrypoint;
            Overview.FileHeaderPointer = DosHeader.e_lfanew;
            Overview.ImageBase = OptionalHeader32.ImageBase;
            Overview.NumberOfSections = FileHeader.NumberOfSections;
            Overview.SizeOfHeaders = OptionalHeader32.SizeOfHeaders;
            Overview.SizeOfImage = OptionalHeader32.SizeOfImage;
        }

        public IntPtr GetProcessHandle()
        {
            if (Handle != IntPtr.Zero)
                return Handle;
            if (IsProcess)
                Handle = OpenProcess(0x1F0FFF, false, ProcessID);
            return Handle;
        }

        public void CloseProcessHandle()
        {
            if (Handle == IntPtr.Zero)
                return;

            if (IsProcess)
            {
                if (CloseHandle(Handle))
                    Handle = IntPtr.Zero;
            }
        }


    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // STRUCTURES

    [StructLayout(LayoutKind.Sequential)]
    public struct IMAGE_DATA_DIRECTORIES
    {
        public uint ExportTableRva;
        public uint SizeOfExportTable;
        public uint ImportTableRva;
        public uint SizeOfImportTable;
        public uint ResourceTableRva;
        public uint SizeOfResourceTable;
        public uint ExceptionTableRva;
        public uint SizeOfExceptionTable;
        public uint CertificateTableRva;
        public uint SizeOfSertificateTable;
        public uint BaseRelocationTable;
        public uint SizeOfBaseRelocation;
        public uint DebugRva;
        public uint SizeOfDebug;
        public uint ArchitechureRva;
        public uint SizeOfArchitechure;
        public uint GlobalPtrRva;
        public uint SizeOfGlobalPointer;
        public uint TLSTable;
        public uint SizeOfTLSTable;
        public uint LoadConfigTableRva;
        public uint SizeOfLoadConfigTable;
        public uint BoundImportRva;
        public uint SizeOfBoundImport;
        public uint ImportAddressTableRva;
        public uint SizeOfImportAddressTable;
        public uint DelayImportDescriptorRva;
        public uint SizeOfDelayImportDescriptor;
        public uint CLRRuntimeHeaderRva;
        public uint SizeOfCLRRumtimeHeader;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
        private byte[] Null;
    }


    [StructLayout(LayoutKind.Sequential)]
    public struct IMAGE_DOS_HEADER
    {
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]
        public char[] e_magic;
        public short e_cblp;
        public short e_cp;
        public short e_crlc;
        public short e_cparhdr;
        public short e_minalloc;
        public short e_maxalloc;
        public short e_ss;
        public short e_sp;
        public short e_csum;
        public short e_ip;
        public short e_cs;
        public short e_lfarlc;
        public short e_ovno;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
        public short[] e_res1;
        public short e_oemid;
        public short e_oeminfo;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 10)]
        public short[] e_res2;
        public uint e_lfanew;
    }


    [StructLayout(LayoutKind.Sequential)]
    public struct IMAGE_FILE_HEADER
    {
        uint Signature;
        public ushort Machine;
        public ushort NumberOfSections;
        public uint TimeDateStamp;
        public uint PointerToSymbolTable;
        public uint NumberOfSymbols;
        public ushort SizeOfOptionalHeader;
        public ushort Characteristics;
    }


    [StructLayout(LayoutKind.Sequential)]
    public struct IMAGE_OPTIONAL_HEADER32
    {
        //Standard Headers
        public ushort Magic;
        public byte MajorLinkedVersion;
        public byte MinorLinkedVersion;
        public uint SizeOfCode;
        public uint SizeOfInitilizedData;
        public uint SizeOfUninitilizedData;
        public uint AddressOfEntrypoint;
        public uint BaseOfCode;
        public uint BaseOfData;

        //Windows NT Headers

        public uint ImageBase;
        public uint SectionAllignment;
        public uint FileAlignment;
        public ushort MajorOperatingSystemVersion;
        public ushort MinorOperatingSystemVersion;
        public ushort MajorImageVersion;
        public ushort MinorImageVersion;
        public ushort MajorSubSystemVersion;
        public ushort MinorSubSystemVersion;
        public uint Win32VersionValue;
        public uint SizeOfImage;
        public uint SizeOfHeaders;
        public uint Checksum;
        public ushort Subsystem;
        public ushort DllCharacteristics;
        public uint SizeOfStacReserve;
        public uint SizeOfStackCommit;
        public uint SizeOfHeapReserve;
        public uint SizeOfHeapCommit;
        public uint LoaderFlags;
        public uint NumberOfRvaAndSizes;
    }


    public struct IMAGE_OVERVIEW
    {
        public uint FileHeaderPointer;
        public uint NumberOfSections;
        public uint AddressOfEntrypoint;
        public uint ImageBase;
        public uint SizeOfImage;
        public uint SizeOfHeaders;
    }


    [StructLayout(LayoutKind.Sequential)]
    public struct IMAGE_SECTION_HEADER
    {
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
        public char[] Name;
        public uint VirtualSize;
        public uint VirtualAddress;
        public uint SizeOfRawData;
        public uint PointerToRawData;
        public uint PointerToRelocations;
        public uint PointerToLineNumber;
        public ushort NumberOfRelocations;
        public ushort NumberOfLineNumbers;
        public uint Characteristics;
    }


    [StructLayout(LayoutKind.Sequential)]
    public struct MEMORY_BASIC_INFORMATION
    {
        public IntPtr BaseAddress;
        public IntPtr AllocationBase;
        public uint AllocationProtect;
        public uint RegionSize;
        public uint State;
        public uint Protect;
        public uint Type;
    }


    [StructLayout(LayoutKind.Sequential)]
    public struct MODULE_INFO
    {
        public IntPtr lpBaseOfDll;
        public uint SizeOfImage;
        public IntPtr EntryPoint;
    }



}
public static class ProcessExtension
{
    [Flags]
    public enum ThreadAccess
    {
        TERMINATE = (0x0001),
        SUSPEND_RESUME = (0x0002),
        GET_CONTEXT = (0x0008),
        SET_CONTEXT = (0x0010),
        SET_INFORMATION = (0x0020),
        QUERY_INFORMATION = (0x0040),
        SET_THREAD_TOKEN = (0x0080),
        IMPERSONATE = (0x0100),
        DIRECT_IMPERSONATION = (0x0200)
    }
    [DllImport("kernel32.dll")]
    static extern IntPtr OpenThread(ThreadAccess dwDesiredAccess, bool bInheritHandle, uint dwThreadId);

    [DllImport("kernel32.dll")]
    static extern uint SuspendThread(IntPtr hThread);

    [DllImport("kernel32.dll")]
    static extern int ResumeThread(IntPtr hThread);

    [DllImport("kernel32.dll", SetLastError = true, CallingConvention = CallingConvention.Winapi)]
    [return: MarshalAs(UnmanagedType.Bool)]

    private static extern bool IsWow64Process([In] IntPtr process, [Out] out bool wow64Process);

    public static bool IsRunning(this Process process)
    {
        if (process == null)
            throw new ArgumentNullException(nameof(process));

        try
        {
            Process.GetProcessById(process.Id);
        }
        catch (ArgumentException)
        {
            return false;
        }
        return true;
    }
    public static bool Is64Bit(this Process process)
    {
        try
        {
            try
            {
                ProcessModule handle = process.MainModule;
            }
            catch (Exception)
            {
                return true;
            }
            bool isWow64;
            if (!IsWow64Process(process.Handle, out isWow64))
                throw new Win32Exception();
            return !isWow64;
        }
        catch (Exception)
        {
            return true;
        }

    }


    public static void Suspend(this Process process)
    {
        foreach (ProcessThread thread in process.Threads)
        {
            var pOpenThread = OpenThread(ThreadAccess.SUSPEND_RESUME, false, (uint)thread.Id);
            if (pOpenThread == IntPtr.Zero)
            {
                break;
            }
            SuspendThread(pOpenThread);
        }
    }
    public static void Resume(this Process process)
    {
        foreach (ProcessThread thread in process.Threads)
        {
            var pOpenThread = OpenThread(ThreadAccess.SUSPEND_RESUME, false, (uint)thread.Id);
            if (pOpenThread == IntPtr.Zero)
            {
                break;
            }
            ResumeThread(pOpenThread);
        }
    }


    /*
    public class ListBoxWriter : TextWriter //this class redirects console.writeline to debug listbox
    {
        private readonly ListBox _list;
        private StringBuilder _content = new StringBuilder();

        public ListBoxWriter(ListBox list)
        {
            _list = list;
        }

        public override Encoding Encoding
        {
            get { return Encoding.UTF8; }
        }

        public override void Write(char value)
        {
            base.Write(value);
            _content.Append(value);

            if (value != '\n') return;
            if (_list.InvokeRequired)
            {
                try
                {
                    _list.Invoke(new MethodInvoker(() => _list.Items.Add(_content.ToString())));
                    _list.Invoke(new MethodInvoker(() => _list.SelectedIndex = _list.Items.Count - 1));
                    _list.Invoke(new MethodInvoker(() => _list.SelectedIndex = -1));
                }
                catch (ObjectDisposedException ex)
                {
                    Console.WriteLine("NAH");
                }
            }
            else
            {
                _list.Items.Add(_content.ToString());
                _list.SelectedIndex = _list.Items.Count - 1;
                _list.SelectedIndex = -1;
            }
            _content = new StringBuilder();
        }
    } 
    */


    /// /////////////////////////////////////////////////////////////////////////////////////////////


    /*
    VIRUSTOTAL FUNCTION - NOT YET IMPLEMENTED - CREDITS TO DH_TOOLS.CS
        private void button2_Click(object sender, EventArgs e)
        {
            openFileDialog1.ShowDialog();
            if (File.Exists(openFileDialog1.FileName))
            {
                textBox1.Text = openFileDialog1.FileName;
            }
        }

        private void button3_Click(object sender, EventArgs e)
        {

            DH_Tools tools = new DH_Tools();

            if (File.Exists(textBox1.Text))
            {

                string md5 = tools.md5file(textBox1.Text);

                listView1.Items.Clear();
                richTextBox1.Clear();

                string apikey = "07d6f7d301eb1ca58931a396643b91e4c98f830dcaf52aa646f034c876689064"; // API Key
                textBox2.Text = "[+] Scanning ...";
                this.Refresh();

                string code = tools.tomar("http://www.virustotal.com/vtapi/v2/file/report", "resource=" + md5 + "&apikey=" + apikey);
                code = code.Replace("{\"scans\":", "");

                string anti = "";
                string reanti = "";

                Match regex = Regex.Match(code, "\"(.*?)\": {\"detected\": (.*?), \"version\": (.*?), \"result\": (.*?), \"update\": (.*?)}", RegexOptions.IgnoreCase);

                while (regex.Success)
                {
                    anti = regex.Groups[1].Value;
                    reanti = regex.Groups[4].Value;
                    reanti = reanti.Replace("\"", "");

                    ListViewItem item = new ListViewItem();

                    if (reanti == "null")
                    {
                        item.ForeColor = Color.Cyan;
                        reanti = "Clean";
                    }

                    else
                    {
                        item.ForeColor = Color.Red;
                    }

                    item.Text = anti;
                    item.SubItems.Add(reanti);

                    listView1.Items.Add(item);

                    regex = regex.NextMatch();
                }

                regex = Regex.Match(code, "\"scan_id\": \"(.*?)\"", RegexOptions.IgnoreCase);
                if (regex.Success)
                {
                    richTextBox1.AppendText("[+] Scan_ID : " + regex.Groups[1].Value + Environment.NewLine);
                }

                else
                {
                    MessageBox.Show("Not Found");
                }

                regex = Regex.Match(code, "\"scan_date\": \"(.*?)\"", RegexOptions.IgnoreCase);
                if (regex.Success)
                {
                    richTextBox1.AppendText("[+] Scan_Date : " + regex.Groups[1].Value + Environment.NewLine);
                }

                regex = Regex.Match(code, "\"permalink\": \"(.*?)\"", RegexOptions.IgnoreCase);

                if (regex.Success)
                {
                    richTextBox1.AppendText("[+] PermaLink : " + regex.Groups[1].Value + Environment.NewLine);
                }

                regex = Regex.Match(code, "\"verbose_msg\": \"(.*?)\", \"total\": (.*?), \"positives\": (.*?),", RegexOptions.IgnoreCase);
                if (regex.Success)
                {
                    richTextBox1.AppendText("[+] Founds : " + regex.Groups[3].Value + "/" + regex.Groups[2].Value + Environment.NewLine);
                }

                textBox2.Text = "[+] Finished";
                this.Refresh();


            }
            else
            {
                MessageBox.Show("File not found");
            }


        }
        */






    ///////////////////////////////////////////////////////////////////


}